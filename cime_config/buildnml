#!/usr/bin/env python3

"""
CAM namelist creator
"""
import sys
import os
import re
import shutil
import logging
import glob

_CIMEROOT = os.environ.get("CIMEROOT")
if _CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")

_LIBDIR = os.path.join(_CIMEROOT, "CIME", "Tools")
sys.path.append(_LIBDIR)
# pylint: disable=wildcard-import, wrong-import-position
# pylint: disable=unused-wildcard-import
from CIME.Tools.standard_script_setup import *
from CIME.XML.standard_module_setup   import *
from CIME.buildnml                    import create_namelist_infile, parse_input
from CIME.case                        import Case
from CIME.utils                       import expect

# Save local (cime_config) directory path:
_CIME_CONFIG_PATH = os.path.dirname(os.path.abspath(__file__))

# Add local (cime_config) directory to python path:
sys.path.append(_CIME_CONFIG_PATH)

# Import CAM's configure structure:
from cam_config import ConfigCAM
# HistoryConfig allows translation from user_nl_cam into Fortran namelists
from hist_config import HistoryConfig

#Import CAM's ParamGen class:
from atm_in_paramgen import AtmInParamGen

# Open CIME case log:
_LOGGER = logging.getLogger(__name__)

# Beginning of valid user_nl configuration line
_USER_NL_LINE = re.compile(r"^[a-z][a-z0-9_]*[ ]*=", re.IGNORECASE)

#################
#HELPER FUNCTIONS
#################

class CamBuildnmlError(ValueError):
    """Class used to handle CAM buildnml errors
    (e.g., log user errors without backtrace)"""

##################

# This simplifies the filename mangling for different cases.
def _create_ic_filename(inst_string, i_or_r,
                        run_refcase, run_refdate, run_reftod):
    """Simplify the filename mangling for different cases."""
    return f"{run_refcase}.cam{inst_string}.{i_or_r}.{run_refdate}-{run_reftod}.nc"

##################

def nml_attr_set(config):

    """
    Creates a dictionary of namelist attributes
    from the CAM config object, in order to properly
    set namelist defaults.
    """

    #Create new (empty) namelist attribute dictionary:
    cam_nml_attr_dict = {}

    if config:
        #Loop over all CAM configuration settings in config dictionary:
        for conf_name in config.config_dict:
            #Extract config setting info from dictionary:
            conf = config.config_dict[conf_name]

            #Determine if each configuration setting
            #is also a namelist attribute:
            if conf.is_nml_attr:
                #If so, then add to attribute dictionary:
                cam_nml_attr_dict[conf_name] = str(conf.value)
            # End if
        # End for
    # End if
    #Return namelist attribute dictionary:
    return cam_nml_attr_dict

##################

def nml_file_dict_update(nml_fil_dict, nml_def_fils):

    """
    Updates a dictionary of namelist definition
    files using a list of provided file paths.
    ----------
    nml_fil_dict -> Dictionary of nml definition files.
                    It is assumed to be organized as
                    {file name : file path}

    nml_def_fils -> List of path-like variables associated
                    with specific namelist definition files.

    """

    # Loop over all found files:
    for nml_def_fil in nml_def_fils:
        fil_name = os.path.basename(nml_def_fil)
        if fil_name in nml_fil_dict:
            fil_dir = os.path.dirname(os.path.abspath(nml_def_fil))
            # Print message to logger:
            _LOGGER.info("     ...found namelist definition file %s in %s",
                      fil_name, fil_dir)
            # Replace file path with SourceMods path
            nml_fil_dict[fil_name] = nml_def_fil
        #End if
    #End fof

    # Return updated dictionary:
    return nml_fil_dict

#################
#PRIMARY FUNCTION
#################

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    # pylint: disable=too-many-locals
    """Build the cam namelist """

    # Build the component namelist
    if compname != "cam":
        emsg = "CAM buildnml called with model={}"
        raise AttributeError(emsg.format(compname))
    # End if
    srcroot             = case.get_value("SRCROOT")
    rundir              = case.get_value("RUNDIR")
    cam_namelist_opts   = case.get_value("CAM_NAMELIST_OPTS")
    cam_nml_use_case    = case.get_value("CAM_NML_USE_CASE")
    ninst_atm           = case.get_value("NINST_ATM")
    run_type            = case.get_value("RUN_TYPE")
    run_startdate       = case.get_value("RUN_STARTDATE")
    run_refcase         = case.get_value("RUN_REFCASE")
    run_refdate         = case.get_value("RUN_REFDATE")
    run_reftod          = case.get_value("RUN_REFTOD")

    testsrc = os.path.join(srcroot, "components", "cam")
    if os.path.exists(testsrc):
        srcroot = testsrc

    #--------------------------------------------------------------------------
    # Call config_CAM to set the configuration options needed to
    # generate CAM's namelist
    #--------------------------------------------------------------------------

    # Create CAM  configure object:
    config = ConfigCAM(case, _LOGGER)

    #----------------------------------------------------------
    #Auto-generate model code and meta-data needed for namelist:
    #----------------------------------------------------------

    #Set number of spaces used to indicate scope in generated code:
    gen_indent = 3

    #Generate model code and meta-data:
    config.generate_cam_src(gen_indent)

    #----------------------------------------------------------------
    # Create namelist attribute dictionary (to set namelist defaults):
    #----------------------------------------------------------------

    cam_nml_dict = nml_attr_set(config)

    #------------------------------------------------
    # Extract dictionary of namelist definition files
    #------------------------------------------------

    xml_nml_dict = config.xml_nml_def_files

    #--------------------------------------------------
    # Check for namelist definition files in SourceMods
    #--------------------------------------------------

    # Check for SourceMods directory:
    user_xml_dir = os.path.join(caseroot, "SourceMods", "src.cam")
    expect(os.path.isdir(user_xml_dir),
           f"user_xml_dir {user_xml_dir} does not exist ")

    # Search for any possible host model namelist definition files:
    nml_def_fils = glob.glob(os.path.join(user_xml_dir,
                                          "namelist_definition_*.xml"))

    # Now search for CCPP namelist definition files:
    ccpp_nml_fils = glob.glob(os.path.join(user_xml_dir,
                                          "*_namelist.xml"))

    # Combine file lists:
    nml_def_fils.extend(ccpp_nml_fils)

    # Update namelist definition file dict with new files:
    xml_nml_dict = nml_file_dict_update(xml_nml_dict, nml_def_fils)

    #--------------------------
    # Construct ParamGen objects:
    #--------------------------

    pg_atm_list = []

    for xml_fil in xml_nml_dict.values():
        pg_obj = AtmInParamGen.from_namelist_xml(xml_fil)
        pg_atm_list.append(pg_obj)

    #--------------------------------------
    # Combine all ParamGen objects together:
    #---------------------------------------

    pg_atm = pg_atm_list[0]

    for pg_obj in pg_atm_list[1:]:
        pg_atm.append_atm_in_pg(pg_obj)

    #------------------------
    # Loop over all instances:
    #------------------------

    # Set input data list file name:
    input_data_list = os.path.join(caseroot, "Buildconf", "cam.input_data_list")

    # Determine the CAM confdir directory (and make it if it doesn't exist):
    confdir = os.path.join(caseroot, "Buildconf", "camconf")
    if not os.path.isdir(confdir):
        os.makedirs(confdir)

    # Convert instance number to integer:
    ninst = int(ninst_atm)

    for inst_counter in range(1, ninst+1):

        #----------------------
        # Remove old input data:
        #----------------------

        if os.path.isfile(input_data_list):
            os.remove(input_data_list)

        # -----------------------------------------------------
        # Determine instance string
        # -----------------------------------------------------

        inst_string = ""
        if ninst > 1:
            single_case_rpointer = os.path.join(rundir, "rpointer.atm")
            inst_string = '_%04d' % inst_counter
            instance_rpointer = os.path.join(rundir, "rpointer.atm"+inst_string)

            # If multi-instance case does not have restart file, use
            # single-case restart for each instance

            if os.path.isfile(single_case_rpointer) and \
               not os.path.isfile(instance_rpointer):
                shutil.copy(single_case_rpointer, instance_rpointer)
            # End if
        # End if

        # -----------------------------------------------------
        # Create camconf/namelist
        # -----------------------------------------------------

        infile_lines = []

        # Set "ncdata" namelist variable if doing a hybrid run:
        if run_type == 'hybrid':
            ncdata = _create_ic_filename(inst_string, 'i',
                                         run_refcase, run_refdate, run_reftod)
            # Fallback if no instance-specific file is found.
            if not os.path.isfile(os.path.join(rundir, ncdata)):
                ncdata = _create_ic_filename('', 'i', run_refcase,
                                             run_refdate, run_reftod)
            # End if
            infile_lines.append(" ncdata = '" + ncdata + "'")
            if ninst > 1:
                _LOGGER.info("%s is being used for ncdata", ncdata)
            # End if
        # Set "cam_branch_file" namelist variable if doing a branch run:
        elif run_type == 'branch':
            cam_branch_file = _create_ic_filename(inst_string, 'r',
                                                  run_refcase,
                                                  run_refdate, run_reftod)
            # Fallback if no instance-specific file is found.
            if not os.path.isfile(os.path.join(rundir, cam_branch_file)):
                cam_branch_file = _create_ic_filename('', 'r', run_refcase,
                                                      run_refdate, run_reftod)
            # End if
            infile_lines.append(" cam_branch_file = '" + cam_branch_file + "'")
            if ninst > 1:
                _LOGGER.info("%s is being used for cam_branch_file",
                             cam_branch_file)
            # End if

        # Determine location and name of "user_nl_cam" files:
        user_nl_fname = "user_nl_cam" + inst_string
        user_nl_file = os.path.join(caseroot, user_nl_fname)

        # Temporary user_nl file with history config stripped
        user_nl_temp = os.path.join(confdir, "user_nl_temp")
        if os.path.exists(user_nl_temp):
            os.remove(user_nl_temp)
        # end if

        # Remove history configuration from the normal user_nl content
        with open(user_nl_file, 'r') as infile:
            clines = infile.readlines()
        # end with
        with open(user_nl_temp, 'w') as outfile:
            for line in clines:
                sline = line.strip()
                if ((not sline) or (sline[0] == '!') or
                    (_USER_NL_LINE.match(sline) is not None)):
                    outfile.write(line)
                # end if
            # end or
        # end with

        # Check that file actually exists.  If not then throw an error:
        if not os.path.exists(user_nl_file):
            emsg = "The file 'user_nl_cam' is missing.  Please run 'case.setup' first."
            raise CamBuildnmlError(emsg)

        # Determine location and name of namelist input file:
        namelist_infile = os.path.join(confdir, "namelist_infile")

        #--------------------------------
        # Create CIME namelist input file:
        #--------------------------------
        create_namelist_infile(case, user_nl_file, namelist_infile,
                               "\n".join(infile_lines))

        #-------------------------------------------
        # Add user_nl_cam entries to ParamGen object:
        #-------------------------------------------

        pg_atm.append_user_nl_file(user_nl_file)

        #-----------------------------------------------------------
        # Determine CCPP physics suite chosen by user, and set suite
        # name to be a namelist attribute:
        #-----------------------------------------------------------

        # Find user-chosen CCPP physics suite, and set as an attribute:
        config.ccpp_phys_set(cam_nml_dict, pg_atm.data["physics_nl"])

        #-------------------------------------------------
        # Set "nlev" attribute using "pver" namelist entry:
        #-------------------------------------------------

        #Extract pver dictionary:
        pver_dict = pg_atm.data["vert_coord_nl"]["pver"]

        #Create new ParamGen object using pver data dictionary:
        pg_pver = AtmInParamGen(pver_dict)

        #Reduce pg_pver dictionary:
        pg_pver.reduce_atm_in(case, cam_nml_dict)

        #Extract pver value and add to namelist attributes dict:
        cam_nml_dict["nlev"] = pg_pver.data["values"]

        #---------------------------------
        # Set all ParamGen namelist values:
        #---------------------------------

        pg_atm.reduce_atm_in(case, cam_nml_dict)

        #---------------------------
        # Write out Fortran namelist:
        #---------------------------

        # Create resolved CAM namelist file name:
        namelist_file = os.path.join(rundir, "atm_in")

        # Change namelist file name depending on instance:
        namelist_file += inst_string

        # Create CAM namelist using CIME's nmlgen routine:
        pg_atm.write(namelist_file)

        # Add history namelists to atm_in
        hist_configs = HistoryConfig(filename=user_nl_file, logger=_LOGGER)
        with open(namelist_file, 'a', encoding='utf-8') as nl_file:
            hist_configs.output_class_namelist(nl_file)
            for key in sorted(hist_configs.keys()):
                hist_configs[key].output_config_namelist(nl_file, logger=_LOGGER)
            # end for
        # end with


###############################################################################
def _main_func():

    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "cam")
    # End with

if __name__ == "__main__":
    _main_func()
