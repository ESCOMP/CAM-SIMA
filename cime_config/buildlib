#!/usr/bin/env python3

"""
create the cam library
"""
# Python system imports
import sys
import os
import filecmp
import shutil
import logging

from cam_config import ConfigCAM # CAM's configure structure

# Check for the CIME library, and add it
# to the python path:
__CIMEROOT = os.environ.get("CIMEROOT")
if __CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")
sys.path.append(os.path.join(__CIMEROOT, "scripts", "lib"))

#pylint: disable=wrong-import-position
# CIME imports
from CIME.case import Case
from CIME.utils import run_cmd, expect
from CIME.utils import check_minimum_python_version, stop_buffering_output
from CIME.buildlib import parse_input
from CIME.build import get_standard_makefile_args
#pylint: enable=wrong-import-position

check_minimum_python_version(2, 7)
stop_buffering_output()

_LOGGER = logging.getLogger(__name__)

###############################################################################
def _build_cam():
###############################################################################
    """Configure and build CAM"""
    caseroot, libroot, bldroot = parse_input(sys.argv)

    with Case(caseroot) as case:

        # Case variables
        casetools = case.get_value("CASETOOLS")
        atm_root = case.get_value("COMP_ROOT_DIR_ATM")
        gmake_j = case.get_value("GMAKE_J")
        gmake = case.get_value("GMAKE")
        exeroot = case.get_value("EXEROOT")

        # Case-derived variables
        source_mods_dir = os.path.join(caseroot, "SourceMods", "src.cam")
        bldroot = os.path.join(exeroot, "atm", "obj")

        # Set logging level
        if case.get_value("DEBUG"):
            # CIME blocks this change so create a handler with DEBUG level
            handler = logging.StreamHandler(stream=sys.stdout)
            handler.setLevel(logging.DEBUG)
            _LOGGER.handlers = [handler]
            _LOGGER.setLevel(logging.DEBUG)
        else:
            _LOGGER.setLevel(logging.INFO)
        # End if

        # Create CAM config object:
        config = ConfigCAM(case, _LOGGER)

        #Set number of spaces used to indicate scope in generated code:
        gen_indent = 3

        # Re-run source generator in case registry, CCPP suites, or
        # generator scripts have been modified, and
        # to extract required source code paths:
        config.generate_cam_src(gen_indent)

        dycore = config.get_value('dyn')
        reg_dir = config.get_value('reg_dir')
        init_dir = config.get_value('init_dir')
        phys_dirs_str = config.get_value('phys_dirs')

        #Convert the phys_dirs_str into a proper list:
        phys_dirs = phys_dirs_str.split(';')

        #-------------------------------------------------------
        # Create the Filepath file with all the paths needed
        # to build this configuration of CAM
        #-------------------------------------------------------
        filepath_src = os.path.join(caseroot, "Buildconf",
                                    "camconf", "Filepath")
        filepath_dst = os.path.join(bldroot, "Filepath")
        paths = [source_mods_dir, reg_dir, init_dir,
                 os.path.join(atm_root, "src", "data"),
                 os.path.join(atm_root, "src", "control"),
                 os.path.join(atm_root, "src", "cpl",
                              case.get_value("COMP_INTERFACE")),
                 os.path.join(atm_root, "src", "dynamics", "utils"),
                 os.path.join(atm_root, "src", "physics", "utils"),
                 os.path.join(atm_root, "src", "utils")]
        for path in phys_dirs:
            if path not in paths:
                paths.append(path)
            # End if
        # End for

        # Add dynamics source code directories:
        for direc in config.get_value("dyn_src_dirs"):
            dyn_dir = os.path.join(atm_root, "src", "dynamics", direc)
            if dyn_dir not in paths:
                #Add to list of filepaths if not already present:
                paths.append(dyn_dir)

        # Add analytical IC source code directories:
        paths.append(os.path.join(atm_root, "src", "dynamics", "tests")) #Required due to namelist call.
        if dycore != "none":
            paths.append(os.path.join(atm_root, "src", "dynamics", "tests",
                                      "initial_conditions"))

        # If using the CMEPS/NUOPC coupler, then add additional path:
        if case.get_value("COMP_INTERFACE") == "nuopc":
            paths.append(os.path.join(__CIMEROOT, "src", "drivers",
                                      "nuopc", "nuopc_cap_share"))
        # End if

        # Write Filepath text file
        with open(filepath_src, "w", encoding='utf-8') as filepath:
            filepath.write("\n".join(paths))
            filepath.write("\n")
        # End with

        # Move Filepath to the bld directory unless it has not changed
        if os.path.isfile(filepath_dst):
            if not filecmp.cmp(filepath_src, filepath_dst):
                shutil.move(filepath_src, filepath_dst)
            # End if
        else:
            shutil.move(filepath_src, filepath_dst)
        # End if

        #-------------------------------------------------------
        # build the library
        #-------------------------------------------------------
        complib = os.path.join(libroot, "libatm.a")
        makefile = os.path.join(casetools, "Makefile")

        cmd = "{} complib -j {} MODEL=cam COMPLIB={} -f {} {} " \
            .format(gmake, gmake_j, complib, makefile,
                    get_standard_makefile_args(case))

        # Add C Pre-Processor (CPP) definitions, if present:
        if config.cpp_defs:
            cmd += " USER_CPPDEFS='{}'".format(' '.join(config.cpp_defs))

        retcode, out, err = run_cmd(cmd)
        _LOGGER.info("%s: \n\n output:\n %s \n\n err:\n\n%s\n", cmd, out, err)
        expect(retcode == 0, "Command {} failed with rc={}".format(cmd, retcode))

###############################################################################

if __name__ == "__main__":
    _build_cam()
