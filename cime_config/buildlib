#!/usr/bin/env python3

"""
create the cam library
"""
# Python system imports
import sys
import os
import filecmp
import shutil
import logging

from cam_config import ConfigCAM # CAM's configure structure

# Check for the CIME library, and add it
# to the python path:
__CIMEROOT = os.environ.get("CIMEROOT")
if __CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")
sys.path.append(os.path.join(__CIMEROOT, "CIME", "Tools"))

#pylint: disable=wrong-import-position
# CIME imports
from CIME.case import Case
from CIME.utils import run_cmd, expect
from CIME.utils import stop_buffering_output
from CIME.buildlib import parse_input
from CIME.build import get_standard_makefile_args
from CIME.Tools.standard_script_setup import check_minimum_python_version
#pylint: enable=wrong-import-position

check_minimum_python_version(3, 7) #CAM requires version 3.7 or greater
stop_buffering_output()

_LOGGER = logging.getLogger(__name__)

###############################################################################
def _build_cam():
###############################################################################
    """Configure and build CAM"""
    caseroot, libroot, bldroot = parse_input(sys.argv)

    with Case(caseroot) as case:

        # Case variables
        casetools = case.get_value("CASETOOLS")
        atm_root = case.get_value("COMP_ROOT_DIR_ATM")
        gmake_j = case.get_value("GMAKE_J")
        gmake = case.get_value("GMAKE")
        exeroot = case.get_value("EXEROOT")

        # Case-derived variables
        source_mods_dir = os.path.join(caseroot, "SourceMods", "src.cam")
        bldroot = os.path.join(exeroot, "atm", "obj")

        # Set logging level
        if case.get_value("DEBUG"):
            # CIME blocks this change so create a handler with DEBUG level
            handler = logging.StreamHandler(stream=sys.stdout)
            handler.setLevel(logging.DEBUG)
            _LOGGER.handlers = [handler]
            _LOGGER.setLevel(logging.DEBUG)
        else:
            _LOGGER.setLevel(logging.INFO)
        # End if

        # Create CAM config object:
        config = ConfigCAM(case, _LOGGER)

        #Set number of spaces used to indicate scope in generated code:
        gen_indent = 3

        # Re-run source generator in case registry, CCPP suites, or
        # generator scripts have been modified, and
        # to extract required source code paths:
        config.generate_cam_src(gen_indent)

        dycore = config.get_value('dyn')
        reg_dir = config.get_value('reg_dir')
        init_dir = config.get_value('init_dir')
        phys_dirs_str = config.get_value('phys_dirs')

        #Convert the phys_dirs_str into a proper list:
        phys_dirs = phys_dirs_str.split(';')

        #-------------------------------------------------------
        # Create the Filepath file with all the paths needed
        # to build this configuration of CAM
        #-------------------------------------------------------
        filepath_src = os.path.join(caseroot, "Buildconf",
                                    "camconf", "Filepath")
        filepath_dst = os.path.join(bldroot, "Filepath")
        paths = [source_mods_dir, reg_dir, init_dir,
                 os.path.join(atm_root, "src", "data"),
                 os.path.join(atm_root, "src", "control"),
                 os.path.join(atm_root, "src", "cpl",
                              case.get_value("COMP_INTERFACE")),
                 os.path.join(atm_root, "src", "dynamics", "utils"),
                 os.path.join(atm_root, "src", "physics", "utils"),
                 os.path.join(atm_root, "src", "utils")]
        for path in phys_dirs:
            if path not in paths:
                paths.append(path)
            # End if
        # End for

        # Add dynamics source code directories:
        for direc in config.get_value("dyn_src_dirs"):
            dyn_dir = os.path.join(atm_root, "src", "dynamics", direc)
            if dyn_dir not in paths:
                #Add to list of filepaths if not already present:
                paths.append(dyn_dir)

        # Add analytical IC source code directories:
        paths.append(os.path.join(atm_root, "src", "dynamics", "tests")) #Required due to namelist call.
        if dycore != "none":
            paths.append(os.path.join(atm_root, "src", "dynamics", "tests",
                                      "initial_conditions"))

        # If using the CMEPS/NUOPC coupler, then add additional path:
        if case.get_value("COMP_INTERFACE") == "nuopc":
            paths.append(os.path.join(__CIMEROOT, "src", "drivers",
                                      "nuopc", "nuopc_cap_share"))
        # End if

        # Write Filepath text file
        with open(filepath_src, "w", encoding='utf-8') as filepath:
            filepath.write("\n".join(paths))
            filepath.write("\n")
        # End with

        # Move Filepath to the bld directory unless it has not changed
        if os.path.isfile(filepath_dst):
            if not filecmp.cmp(filepath_src, filepath_dst):
                shutil.move(filepath_src, filepath_dst)
            # End if
        else:
            shutil.move(filepath_src, filepath_dst)
        # End if

        #-------------------------------------------------------
        # build the library
        #-------------------------------------------------------
        complib = os.path.join(libroot, "libatm.a")
        makefile = os.path.join(casetools, "Makefile")

        cmd = f"{gmake} complib -j {gmake_j} MODEL=cam COMPLIB={complib}"
        cmd += f" -f {makefile} {get_standard_makefile_args(case)} "

        # Add C Pre-Processor (CPP) definitions, if present:
        if config.cpp_defs:
            ccpp_defs_str = ' '.join(config.cpp_defs)
            cmd += f" USER_CPPDEFS='{ccpp_defs_str}'"

        retcode, out, err = run_cmd(cmd)
        _LOGGER.info("%s: \n\n output:\n %s \n\n err:\n\n%s\n", cmd, out, err)
        expect(retcode == 0, f"Command {cmd} failed with rc={retcode}")

        # If dynamical core is MPAS, build it after CAM due to dependencies.
        if dycore == "mpas":
            _build_mpas(case)

def _build_mpas(case: Case) -> None:
    """
    Build MPAS by invoking its build infrastructure.
    """

    case_root    = os.path.normpath(case.get_value("CASEROOT"))
    atm_src_root = os.path.normpath(case.get_value("COMP_ROOT_DIR_ATM"))
    atm_bld_root = os.path.normpath(os.path.join(case.get_value("EXEROOT"), "atm", "obj"))
    lib_root     = os.path.normpath(os.path.join(case.get_value("EXEROOT"), "lib"))

    gmake   = case.get_value("GMAKE")
    gmake_j = case.get_value("GMAKE_J")

    mpas_dycore_src_root = os.path.join(atm_src_root, "src", "dynamics", "mpas", "dycore", "src")
    mpas_dycore_bld_root = os.path.join(atm_bld_root, "mpas")

    # Make sure `mpas_dycore_src_root` exists. If not, it is likely that `./manage_externals/checkout_externals` did not succeed.
    if os.path.isfile(mpas_dycore_src_root):
        raise FileExistsError(1, "Unexpected file", mpas_dycore_src_root)

    if not os.path.isdir(mpas_dycore_src_root):
        raise FileNotFoundError(1, "No such directory", mpas_dycore_src_root)

    # MPAS supports "in-source" build only. Copy source code to `mpas_dycore_bld_root` to avoid polluting `mpas_dycore_src_root`.
    if os.path.isfile(mpas_dycore_bld_root):
        raise FileExistsError(1, "Unexpected file", mpas_dycore_bld_root)

    shutil.copytree(mpas_dycore_src_root, mpas_dycore_bld_root, copy_function=_copy2_as_needed, dirs_exist_ok=True)
    _copy2_as_needed(os.path.normpath(os.path.join(mpas_dycore_src_root, "../../Makefile.in.CESM")), os.path.join(mpas_dycore_bld_root, "Makefile.in.CESM"))

    # Invoke makefile target `libmpas-prepare`.
    mpas_dycore_make_command  = f'{gmake} -C {mpas_dycore_bld_root} libmpas-prepare ESM="CESM" CASEROOT="{case_root}" LIBROOT="{lib_root}" '
    mpas_dycore_make_command += f'FCINCLUDES="-I{atm_bld_root}"'

    (sta, out, err) = run_cmd(mpas_dycore_make_command, from_dir=mpas_dycore_bld_root)
    _LOGGER.info("* Command %s:\n\n  Output:\n%s\n\n  Error:\n%s\n\n", mpas_dycore_make_command, out, err)
    expect(sta == 0, f"Command {mpas_dycore_make_command} failed with status {sta}")

    # Invoke makefile target `libmpas-build`.
    mpas_dycore_make_command  = f'{gmake} -C {mpas_dycore_bld_root} -j {gmake_j} libmpas-build ESM="CESM" CASEROOT="{case_root}" LIBROOT="{lib_root}" '
    mpas_dycore_make_command += f'FCINCLUDES="-I{atm_bld_root}"'

    (sta, out, err) = run_cmd(mpas_dycore_make_command, from_dir=mpas_dycore_bld_root)
    _LOGGER.info("* Command %s:\n\n  Output:\n%s\n\n  Error:\n%s\n\n", mpas_dycore_make_command, out, err)
    expect(sta == 0, f"Command {mpas_dycore_make_command} failed with status {sta}")

def _copy2_as_needed(src: str, dst: str) -> None:
    """
    Wrapper around `shutil.copy2`. Copy the file `src` to the file or directory `dst` as needed.
    """

    if os.path.isfile(src):
        if os.path.isfile(dst):
            if int(os.path.getmtime(src)) != int(os.path.getmtime(dst)) or os.path.getsize(src) != os.path.getsize(dst):
                # `src` and `dst` are both files but their modification time or size differ.
                # Example scenario: User modified some existing source code files.
                print("1. Copy from", src, "to", dst)
                print(os.path.getmtime(src), os.path.getmtime(dst))
                print(os.path.getsize(src), os.path.getsize(dst))
                shutil.copy2(src, dst)
        else:
            if os.path.isdir(dst) or os.path.isdir(os.path.dirname(dst)):
                # `src` is a new file that does not exist at `dst`.
                # Example scenario: User added some new source code files.
                print("2. Copy from", src, "to", dst)
                shutil.copy2(src, dst)

###############################################################################

if __name__ == "__main__":
    _build_cam()
