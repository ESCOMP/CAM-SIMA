!
! This work (Common Community Physics Package Framework), identified by
! NOAA, NCAR, CU/CIRES, is free of known copyright restrictions and is
! placed in the public domain.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
! THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
! IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
! CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


!>
!! @brief Auto-generated Autogenerated file to read the namelists for all
!!         active CCPP physics schemes.
!!
!! XXgoldyXX: Replace the active scheme finder
!!            algorithm (is_scheme_active) with a hash table to
!!            improve performance.
!!
!
module cam_ccpp_scheme_namelists_single_def


   implicit none
   private

   ! Public interface
   public :: cam_read_ccpp_scheme_namelists

   ! Private interfaces
   private :: set_active_schemes
   private :: is_scheme_active
   private :: clear_active_schemes
   ! Private data
   character(len=63), allocatable :: active_schemes(:)

CONTAINS

   subroutine set_active_schemes(active_schemes_in)
      use cam_abortutils, only: check_allocate
      use string_utils,   only: to_str

      ! Dummy argument
      character(len=*), intent(in) :: active_schemes_in(:)
      ! Local variables
      integer                     :: istat
      character(len=*), parameter :: subname = 'set_active_schemes'

      allocate(active_schemes(size(active_schemes_in)), stat=istat)
      call check_allocate(istat, subname, 'active_schemes', file=__FILE__, line=__LINE__)
      active_schemes(:) = active_schemes_in(:)

   end subroutine set_active_schemes

   logical function is_scheme_active(scheme_name)

      ! Dummy argument
      character(len=*), intent(in) :: scheme_name
      ! Local variable
      integer :: index

      is_scheme_active = .false.
      do index = 1, size(active_schemes)
         if (trim(scheme_name) == trim(active_schemes(index))) then
            is_scheme_active = .true.
            exit
         end if
      end do

   end function is_scheme_active

   subroutine clear_active_schemes()

      deallocate(active_schemes)

   end subroutine clear_active_schemes

   subroutine cam_read_ccpp_scheme_namelists(nlfile, active_schemes, mpi_comm, mpi_root,          &
        mpi_isroot, logunit)
      use banana_namelist, only: autogen_banana_readnl

      ! Dummy arguments
      character(len=*), intent(in)    :: nlfile
      character(len=*), intent(in)    :: active_schemes(:)
      integer,          intent(in)    :: mpi_comm
      integer,          intent(in)    :: mpi_root
      logical,          intent(in)    :: mpi_isroot
      integer,          intent(in)    :: logunit

      ! Local variable
      integer :: nl_unit

      call set_active_schemes(active_schemes)
      open(newunit=nl_unit, file=trim(nlfile), status='old')
      if (is_scheme_active('banana')) then
         call autogen_banana_readnl(nl_unit, mpi_comm, mpi_root, mpi_isroot, logunit)
      end if

      close(nl_unit)
      call clear_active_schemes()

   end subroutine cam_read_ccpp_scheme_namelists

end module cam_ccpp_scheme_namelists_single_def
