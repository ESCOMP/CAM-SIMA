module physics_data

   use ccpp_kinds,   only: kind_phys

   implicit none
   private

   public :: physics_read_data

   !!XXgoldyXX: This data will eventually be 'used' from a module
   !!XXgoldyXX: generated by the CCPP Framework
   character(len=64), parameter :: ccpp_required_data(14) = (/                &
        'air_pressure                                                    ',   &
        'air_pressure_at_interface                                       ',   &
        'air_pressure_of_dry_air                                         ',   &
        'cloud_liquid_water_mixing_ratio                                 ',   &
        'geopotential                                                    ',   &
        'natural_log_of_air_pressure                                     ',   &
        'natural_log_of_air_pressure_at_interface                        ',   &
        'pressure_thickness                                              ',   &
        'pressure_thickness_of_dry_air                                   ',   &
        'rain_water_mixing_ratio                                         ',   &
        'reciprocal_pressure_thickness                                   ',   &
        'surface_geopotential                                            ',   &
        'temperature                                                     ',   &
        'water_vapor_specific_humidity                                   '    &
        /)

   !!XXgoldyXX: Probably should store this information in the registry
   !!           and autogenerate everything in this module except the
   !!           required field list (above).
#if 0
   type :: stdname_to_fieldname
      character(len=64) :: standard_name
      character(len=16) :: field_names(1)
   end type stdname_to_fieldname

   type(stdname_to_fieldname) :: lookup_table(13) = (/                        &
        ('pressure_thickness                                              ',  &
        (/ 'pdel_snapshot' /) ),                                              &
        ('pressure_thickness_of_dry_air                                   ',  &
        (/ 'pdeldry' /) ),                                                    &
        ('water_vapor_specific_humidity                                   ',  &
        (/ 'Q_snapshot' /) ),                                                 &
        ('cloud_liquid_water_mixing_ratio                                 ',  &
        (/ 'CL_snapshot' /) ),                                                &
        ('rain_water_mixing_ratio                                         ',  &
        (/ 'RAINQM_snapshot' /) ),                                            &
        ('geopotential                                                    ',  &
        (/ 'zm_snapshot' /) ),                                                &
        ('temperature                                                     ',  &
        (/ 't_snapshot' /) ),                                                 &
        ('surface_geopotential                                            ',  &
        (/ 'phis_snapshot' /) ),                                              &
        ('natural_log_of_air_pressure_at_interface                        ',  &
        (/ 'lnpint_snapshot' /) ),                                            &
        ('natural_log_of_air_pressure                                     ',  &
        (/ 'lnpmid_snapshot' /) ),                                            &
        ('air_pressure_at_interface                                       ',  &
        (/ 'pint_snapshot' /) ),                                              &
        ('air_pressure                                                    ',  &
        (/ 'pmid_snapshot' /) ),                                              &
        ('reciprocal_pressure_thickness                                   ',  &
        (/ 'rpdel_snapshot' /) ) /)
#endif

   integer, parameter, private :: fieldname_len = 16

   interface read_field
      module procedure read_field_2d
      module procedure read_field_3d
   end interface read_field

!==============================================================================
CONTAINS
!==============================================================================

   logical function read_standard_name(stdname)
      ! Determine whether we should read <stdname> from <data_file>.
      character(len=*),  intent(in)    :: stdname

      integer                          :: index

      read_standard_name = .false.

      do index = 1, size(ccpp_required_data, 1)
         if (trim(stdname) == trim(ccpp_required_data(index))) then
            read_standard_name = .true.
!            fieldname = lookup_table(index)%field_names(1)
            exit
         end if
      end do

   end function read_standard_name

   function arr2str(name_array)
      ! Dummy arguments
      character(len=*), intent(in) :: name_array(:)
      character(len=256)           :: arr2str
      ! Local variables
      integer          :: index
      integer          :: str_pos
      character(len=2) :: sep

      arr2str(1:1) = '('
      sep = '/ '
      str_pos = 2
      do index = 1, size(name_array, 1)
         write(arr2str(str_pos:), '(2a)') sep, trim(name_array(index))
         str_pos = len_trim(arr2str) + 1
         sep = ', '
      end do
      write(arr2str(str_pos:), *) ' /)'
   end function arr2str


   subroutine read_field_2d(file, var_names, timestep, buffer)
      use shr_assert_mod, only: shr_assert_in_domain
      use shr_sys_mod,    only: shr_sys_flush
      use pio,            only: file_desc_t, var_desc_t
      use spmd_utils,     only: masterproc
      use cam_pio_utils,  only: cam_pio_find_var
      use cam_abortutils, only: endrun
      use cam_logfile,    only: iulog
      use cam_field_read, only: cam_read_field

      ! Dummy arguments
      type(file_desc_t), intent(inout) :: file
      character(len=*),  intent(in)    :: var_names(:)
      integer,           intent(in)    :: timestep
      real(kind_phys),   intent(inout) :: buffer(:)
      ! Local variables
      logical                          :: var_found
      character(len=fieldname_len)     :: found_name
      type(var_desc_t)                 :: vardesc
      character(len=*), parameter      :: subname = 'read_field_2d: '

      call cam_pio_find_var(file, var_names, found_name, vardesc, var_found)

      if (var_found) then
         if (masterproc) then
            write(iulog, *) 'Reading input field, ', trim(found_name)
            call shr_sys_flush(iulog)
         end if
         call cam_read_field(found_name, file, buffer, var_found,             &
              timelevel=timestep)
      else
         call endrun(subname//'No variable found in '//arr2str(var_names))
      end if
      if (var_found) then
         call shr_assert_in_domain(buffer, is_nan=.false.,                    &
              varname=trim(found_name),                                       &
              msg=subname//'NaN found in '//trim(found_name))
      else
         call endrun(subname//'Mismatch variable found in '//arr2str(var_names))
      end if
   end subroutine read_field_2d

   subroutine read_field_3d(file, var_names, vcoord_name, timestep, buffer)
      use shr_assert_mod, only: shr_assert_in_domain
      use shr_sys_mod,    only: shr_sys_flush
      use pio,            only: file_desc_t, var_desc_t
      use spmd_utils,     only: masterproc
      use cam_pio_utils,  only: cam_pio_find_var
      use cam_abortutils, only: endrun
      use cam_logfile,    only: iulog
      use cam_field_read, only: cam_read_field
      use physics_grid,   only: pver, pverp

      ! Dummy arguments
      type(file_desc_t), intent(inout) :: file
      character(len=*),  intent(in)    :: var_names(:)
      character(len=*),  intent(in)    :: vcoord_name
      integer,           intent(in)    :: timestep
      real(kind_phys),   intent(inout) :: buffer(:,:)
      ! Local variables
      logical                          :: var_found
      integer                          :: num_levs
      character(len=fieldname_len)     :: found_name
      type(var_desc_t)                 :: vardesc
      character(len=*), parameter      :: subname = 'read_field_3d: '

      call cam_pio_find_var(file, var_names, found_name, vardesc, var_found)

      if (var_found) then
         if (trim(vcoord_name) == 'lev') then
            num_levs = pver
         else if (trim(vcoord_name) == 'ilev') then
            num_levs = pverp
         else
            call endrun(subname//'Unknown vcoord_name, '//trim(vcoord_name))
         end if
         if (masterproc) then
            write(iulog, *) 'Reading input field, ', trim(found_name)
            call shr_sys_flush(iulog)
         end if
         call cam_read_field(found_name, file, buffer, var_found,             &
              timelevel=timestep, dim3name=trim(vcoord_name),                 &
              dim3_bnds=(/1, num_levs/))
      else
         call endrun(subname//'No variable found in '//arr2str(var_names))
      end if
      if (var_found) then
         call shr_assert_in_domain(buffer, is_nan=.false.,                    &
              varname=trim(found_name),                                       &
              msg=subname//'NaN found in '//trim(found_name))
      else
         call endrun(subname//'Mismatch variable found in '//arr2str(var_names))
      end if
   end subroutine read_field_3d

   subroutine physics_read_data(file, timestep)
      use pio,           only: file_desc_t
      use physics_types, only: phys_state, pdel, pdeldry, zm, lnpint, lnpmid
      use physics_types, only: pint, pmid, pmiddry, rpdel
      use physics_types, only: ix_qv, ix_cld_liq, ix_rain

      ! Dummy argument
      type(file_desc_t), intent(inout) :: file
      integer,           intent(in)    :: timestep

      if (read_standard_name('pressure_thickness')) then
         call read_field(file, (/ 'pdel_snapshot' /), 'lev', timestep, pdel)
      end if
      if (read_standard_name('pressure_thickness_of_dry_air')) then
         call read_field(file, (/ 'pdeldry_snapshot' /), 'lev',               &
              timestep, pdeldry)
      end if
      if (read_standard_name('water_vapor_specific_humidity')) then
         call read_field(file, (/ 'Q_snapshot' /), 'lev', timestep,           &
              phys_state%q(:,:,ix_qv))
      end if
      if (read_standard_name('cloud_liquid_water_mixing_ratio')) then
         call read_field(file, (/ 'CL_snapshot' /), 'lev', timestep,          &
              phys_state%q(:,:,ix_cld_liq))
      end if
      if (read_standard_name('rain_water_mixing_ratio')) then
         call read_field(file, (/ 'RAINQM_snapshot' /), 'lev', timestep,      &
              phys_state%q(:,:,ix_rain))
      end if
      if (read_standard_name(                                                 &
           'geopotential')) then
         call read_field(file, (/ 'zm_snapshot' /), 'lev', timestep, zm)
      end if
      if (read_standard_name('temperature')) then
         call read_field(file, (/ 't_snapshot' /), 'lev', timestep,           &
              phys_state%T)
      end if
      if (read_standard_name('surface_geopotential')) then
         call read_field(file, (/ 'phis_snapshot' /), timestep, phys_state%phis)
      end if
      if (read_standard_name('natural_log_of_air_pressure_at_interface')) then
         call read_field(file, (/ 'lnpint_snapshot' /), 'ilev', timestep,     &
              lnpint)
       end if
      if (read_standard_name('natural_log_of_air_pressure')) then
         call read_field(file, (/ 'lnpmid_snapshot' /), 'lev', timestep, lnpmid)
      end if
      if (read_standard_name('air_pressure_at_interface')) then
         call read_field(file, (/ 'pint_snapshot' /), 'ilev', timestep, pint)
      end if
      if (read_standard_name('air_pressure')) then
         call read_field(file, (/ 'pmid_snapshot' /), 'lev', timestep, pmid)
      end if
      if (read_standard_name('air_pressure_of_dry_air')) then
         call read_field(file, (/ 'pmiddry_snapshot' /), 'lev', timestep,     &
              pmiddry)
      end if
      if (read_standard_name('reciprocal_pressure_thickness')) then
         call read_field(file, (/ 'rpdel_snapshot' /), 'lev', timestep, rpdel)
      end if

   end subroutine physics_read_data

end module physics_data
